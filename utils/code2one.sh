#!/bin/bash

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Default values
output_file="code_merged.txt"
exclude_dirs=(".git" "build" "node_modules")
include_dirs=()
exclude_exts=("*.pyc" "*.class" "*.jar")
include_exts=()
verbose=false
format="plain"

help() {
    echo -e "${GREEN}Usage:${NC}"
    echo "  $0 [OPTIONS] <directory1> [directory2...]"
    echo -e "${GREEN}Options:${NC}"
    echo "  -o <file>    Output file (default: code_merged.txt)"
    echo "  -e <dirs>    Excluded dirs (comma separated, default: .git,build,node_modules)"
    echo "  -x <exts>    Excluded extensions (comma separated, default: *.pyc,*.class,*.jar)"
    echo "  -i <dirs>    Included dirs (comma separated)"
    echo "  -y <exts>    Included extensions (comma separated)"
    echo "  -f <format>  Output format (plain|markdown)"
    echo "  -v           Verbose mode"
    echo "  -h           Show this help message"
    exit 0
}

# Parse arguments
while getopts ":o:e:x:i:y:f:vh" opt; do
    case $opt in
        o) output_file="$OPTARG" ;;
        e) IFS=',' read -ra exclude_dirs <<< "$OPTARG" ;;
        x) IFS=',' read -ra exclude_exts <<< "$OPTARG" ;;
        i) IFS=',' read -ra include_dirs <<< "$OPTARG" ;;
        y) IFS=',' read -ra include_exts <<< "$OPTARG" ;;
        f) format="$OPTARG" ;;
        v) verbose=true ;;
        h) help ;;
        \?) echo -e "${RED}Invalid option: -$OPTARG${NC}" >&2; exit 1 ;;
    esac
done
shift $((OPTIND-1))

[ $# -eq 0 ] && echo -e "${RED}Error: No directories specified${NC}" && help

# Verify dependencies
if ! command -v file &> /dev/null; then
    echo -e "${RED}Error: 'file' command not found. Install via 'apt-get install file'${NC}"
    exit 1
fi

$verbose && echo -e "${YELLOW}Starting processing...${NC}"

# Initialize output file
echo "# Generated by code2one.sh on $(date)" > "$output_file"
echo "# Directories: $@" >> "$output_file"
echo "# Included extensions: ${include_exts[*]}" >> "$output_file"
echo "# Excluded extensions: ${exclude_exts[*]}" >> "$output_file"

# Process files
total_files=0
processed_files=0

for directory in "$@"; do
    [ ! -d "$directory" ] && echo -e "${RED}Error: '$directory' does not exist${NC}" && exit 1
    
    $verbose && echo -e "${YELLOW}Scanning $directory...${NC}"
    
    # Build find options for directories
    find_opts=(-type f)
    
    # Logic for included directories
    if [ ${#include_dirs[@]} -ne 0 ]; then
        dir_patterns=""
        for dir in "${include_dirs[@]}"; do
            dir_patterns+=" -path \"*/$dir/*\" -o"
        done
        dir_patterns="${dir_patterns% -o}" # remove last -o
        find_opts+=(-or '(' $dir_patterns ')' )
    fi
    
    # Logic for excluded directories
    for dir in "${exclude_dirs[@]}"; do
        find_opts+=(-not -path "*/$dir/*")
    done
    
    while read -r file; do
        ((total_files++))
        
        # Check binary
        if grep -q "binary" <<< "$(file --mime-encoding "$file" | cut -d' ' -f2)"; then
            $verbose && echo -e "${RED}SKIP: $file (binary)${NC}"
            continue
        fi

        # Logic for included extensions
        if [ ${#include_exts[@]} -ne 0 ]; then
            found_ext=false
            for ext in "${include_exts[@]}"; do
                if [[ "$file" == *"$ext" ]]; then
                    found_ext=true
                    break
                fi
            done
            if [ "$found_ext" = false ]; then
                $verbose && echo -e "${RED}SKIP: $file (not in included extensions)${NC}"
                continue
            fi
        fi
        
        # Logic for excluded extensions
        for ext in "${exclude_exts[@]}"; do
            if [[ "$file" == *"$ext" ]]; then
                $verbose && echo -e "${RED}SKIP: $file (excluded extension)${NC}"
                continue 2
            fi
        done
        
        ((processed_files++))
        $verbose && echo -e "${GREEN}ADD: $file${NC}"
        
        # Format output
        case $format in
            markdown)
                echo -e "\n## File: \`$file\`\n\`\`\`" >> "$output_file"
                cat "$file" >> "$output_file"
                echo -e "\`\`\`" >> "$output_file"
                ;;
            *)
                echo -e "\n=== File: $file ===" >> "$output_file"
                cat "$file" >> "$output_file"
                echo >> "$output_file"
                ;;
        esac
        
    done < <(find "$directory" "${find_opts[@]}" 2>/dev/null)
done

echo -e "${GREEN}\nDone! Processed $processed_files/$total_files files.${NC}"
echo -e "Output saved to ${YELLOW}$output_file${NC}"
